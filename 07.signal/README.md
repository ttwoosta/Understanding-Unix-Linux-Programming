# Software tools and User program

Software tools do not distinguish between disk files and devices, such as `who`, `ls`, `sort`, `grep`. No assumptions about the source and destination of the data being processed. Its input and output can be redirected to any kind of connection.

The program associated with a particular device (eg, a terminal) is called a user program, such as `vim`, `emacs`, `more`. This type of program will set the **terminal driver program** attributes of input and output processing. 

We have already known in terminal:

1. Program can't get input until you input an ENTER. Before you input an ENTER, you can press backspace to delete a character.
2. Your input is echoed on the screen.
3. Ctrl+C will stop your process.

These are all related to **terminal Driver**. Terminal driver is a set of complicated programs in the **kernal**. Driver has a lot of settings. These list as below is frequently used:

- Response to input immediately.
- Echo or not.
- Input timeout.
- Ignore `Ctrl+C`.

# Terminal mode

All these infomation is in `man -k "terminal attrbutes"`

1. **Canonical mode**: Input is made available line by line. An input line is available when one of the line delimiters is typed(EOF, start of line, etc.). Line editing is enabled(ERASE, KILL).

2. **Noncanonical  mode**: Input is available immediately, and line editing is disabled.

3. **Raw mode**: input is available character by character, echoing is disabled, and all special processing of terminal input and output characters is disabled.

See `more04.c`, use `tcgetattr()` and `tcsetattr()` to make this program noncanonial mode.

# Signal(to ignore Ctrl+C)

Our program has 3 steps when we set terminal attributes.

1. Get origin attributes.
2. Set new attributes.
3. Restore origin attributes.

If somebody press `Ctrl+C`, the program will exit immediately and will not execute the following code to restore origin attributes. Return to shell command line, it still maintain nocanonical mode. We should learn how to avoid a process being killed by `Ctrl+C` recklessly.

`Ctrl+C` will kill process. This interupt created by a kernel mechanism named "signal". **Signal is a simple but important concept.**

## What is signal?

What is signal? There are differences between events and signals. Signal is a kind of message consisting of simple information.

- Traffic light is a signal. 
- Stop sign is a signal. 
- The gesture is a signal.

When you press `Ctrl+C`, the kernel sends an interrupt signal to the currently running process. Signal often has a number code. If you change this code, many shell script will go wrong.

Requests to generate signals come from three places:

1. User. eg: `Ctrl+C`
2. The kernel. eg: segment fault, floating point overflow,  illegal machine instruction.
3. Process itself. **Synchronous signals** are generated by the operation of the process, like division by zero. **Asynchronous signals** are generated by events outside the process, like user pressing the keyboard.

You can use this command to learn the list of signal:

~~~
$ man 2 signal 
$ whereis signal.h
$ more /usr/include/signal.h
$ man 7 signal
~~~


## What does signal do?

It depends. Many signals kill the process. But the process have ways to protect itself from being killed.

According to `man signal`, process has 3 choices when it get a signal:

1. **SIG_DFL**, the **default action** associated with the signal (see signal(7)) occurs. Usually the process is killed.
2. **SIG_IGN**, the process tells the kernel that the signal is ignored. So can somebody make process ignore every signal to avoid being killed? The answer is no. Because the signals SIGKILL and SIGSTOP cannot be caught or ignored.
3. The third option is the most powerful one. After the process receives the signal, it calls a specific **signal handler function** (usually called **handler**). After encountering a signal, the kernel calls the function to process this signal. The program immediately jumps to that function, runs its code, and returns to the origin process after processing. It's just like an ordinary procedure call.

- Use `man 2 signal` to learn function prototypes. 
- Use `man 7 signal` is a overview of signals.

See `youcantstopme.c`

# Summary of device programming

1. Understand the properties of the device. `stty`
2. Learn how to control the connection, how to adjust driver properties to meet specific needs. `tcgetattr` and `tcsetattr`
3. Learn how to deal with signals.

